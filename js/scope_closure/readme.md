# JS 执行机制
- 调用栈
    纪录函数的执行顺序，管理执行上下文和变量环境
- 作用域
    变量查找的规则
    当前作用域 -》 冒泡到上级作用域 -》 直到全局作用域
- 作用域链
    变量查找的路劲
- 执行上下文
    函数调用时创建的上下文(代码执行)对象
- 变量环境
    变量提升
- 词法环境
    TDZ
- 词法作用域

在每个执行上下文的变量环境中，都包含一个外部应用outer,用来指向外部的执行上下文。
## 作用域链
- 一段代码使用一个变量时，JS 引擎首先会在当前的执行上下文中查找该变量。
- 沿着outer 指向的外部作用域去查找
- 到全局
查找的路劲就叫作用域链

## 词法作用域
作用域由代码中函数声明的位置来决定，静态的预测代码在执行过程中如何查找变量

词法作用域是代码编译阶段就决定好了的，和函数怎么调用没有关系。

块级作用域在词法环境中表达
先在词法环境中查找，再往变量环境中查找。再继续往全局执行上下文查找。词法环境当中查找。

## 闭包
基础是理解词法作用域等
根据词法作用域的规则，内部函数getName和setName总是可以访问他们的外部函数foo中的变量

根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量（自由变量），
当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了
但是内部函数引用外部函数的变量依然保存在内存中，我们把这些变量的集合称为闭包。
foo 外部函数，这些变量的集合称为foo函数的闭包。
这些变量的集合也是内部函数运行的专属背包

-------------------------------------------------------------------------------------
## 打印全局值的原因
1. 全局作用域声明变量 myName = '骑士' （通过 var 声明，会变量提升）。
2. 调用 foo() 函数，在 foo 函数内部声明局部变量 myName = '极客' （仅在 foo 函数作用域内有效）。
3. foo 函数内部调用 bar() 函数。
### 关键规则：词法作用域
bar 函数的 作用域在定义时确定 （而非调用时）。由于 bar 是在全局作用域中定义的，它的作用域链仅包含全局作用域（不包含 foo 函数的作用域）。

### 变量查找过程
当 bar 函数执行 console.log(myName) 时：

- 首先在 bar 自身的作用域中查找 myName （无定义）。
- 向上级作用域（全局作用域）查找，找到全局变量 myName = '骑士' 。
因此，最终打印的是全局作用域中的 myName 值 '骑士' ，而非 foo 函数内部的局部变量 '极客' 。