<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>荷兰国旗排序动画</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 20px;
      background: #f5f5f5;
    }

    canvas {
      margin: 20px auto;
      background: white;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }

    .controls {
      margin: 10px;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      margin: 0 10px;
    }
  </style>
</head>

<body>
  <h2>荷兰国旗排序动画（Sort Colors）</h2>
  <p>红=0，白=1，蓝=2</p>
  <canvas id="canvas" width="800" height="300"></canvas>
  <div class="controls">
    <button id="restart">重新播放</button>
  </div>

  <script>
    // 获取 Canvas 上下文
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width;
    const H = canvas.height;

    // 配置
    const PADDING = 50;
    const BAR_WIDTH = 60;
    const BAR_HEIGHT = 80;
    const SPACING = 20;
    const COLORS = ['red', 'white', 'blue']; // 0,1,2
    const POINTER_Y = 200;

    // 初始数组（可修改）
    let nums = [2, 0, 2, 1, 1, 0];
    let p0 = 0,
      p1 = 0,
      i = 0;
    let animationId = null;

    // 绘制数组元素
    function drawArray(nums, i, p0, p1, highlight = []) {
      ctx.clearRect(0, 0, W, H);

      nums.forEach((val, idx) => {
        const x = PADDING + idx * (BAR_WIDTH + SPACING);
        const y = 100 - BAR_HEIGHT;

        // 绘制色块
        ctx.fillStyle = COLORS[val];
        ctx.fillRect(x, y, BAR_WIDTH, BAR_HEIGHT);
        ctx.strokeStyle = '#333';
        ctx.strokeRect(x, y, BAR_WIDTH, BAR_HEIGHT);

        // 数字标签
        ctx.fillStyle = val === 2 ? 'black' : 'black';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(val, x + BAR_WIDTH / 2, y + BAR_HEIGHT / 2 + 5);
      });

      // 绘制指针
      const pointers = [{
          label: 'i',
          pos: i,
          color: 'black',
          y: POINTER_Y
        },
        {
          label: 'p0',
          pos: p0,
          color: 'red',
          y: POINTER_Y + 30
        },
        {
          label: 'p1',
          pos: p1,
          color: 'blue',
          y: POINTER_Y + 60
        },
      ];

      pointers.forEach(({
        label,
        pos,
        color,
        y
      }) => {
        const x = PADDING + pos * (BAR_WIDTH + SPACING) + BAR_WIDTH / 2;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - 10, y - 15);
        ctx.lineTo(x + 10, y - 15);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = 'black';
        ctx.font = '14px Arial';
        ctx.fillText(label, x - 10, y + 15);
      });

      // 高亮修改位置
      highlight.forEach(pos => {
        const x = PADDING + pos * (BAR_WIDTH + SPACING);
        ctx.strokeStyle = 'yellow';
        ctx.lineWidth = 4;
        ctx.strokeRect(x, 100 - BAR_HEIGHT, BAR_WIDTH, BAR_HEIGHT);
      });
    }

    // 排序动画主函数
    function animateSort() {
      if (i >= nums.length) {
        drawArray(nums, i, p0, p1); // 最终状态
        return;
      }

      const x = nums[i];
      const highlight = [];

      // 模拟算法步骤
      nums[i] = 2;
      highlight.push(i);

      if (x <= 1) {
        nums[p1] = 1;
        highlight.push(p1);
        p1++;
      }
      if (x === 0) {
        nums[p0] = 0;
        highlight.push(p0);
        p0++;
      }

      // 绘制当前帧
      drawArray(nums, i, p0, p1, highlight);

      i++;

      // 递归调用，形成动画
      animationId = setTimeout(animateSort, 800);
    }

    // 重置并开始动画
    function startAnimation() {
      if (animationId) clearTimeout(animationId);
      nums = [2, 0, 2, 1, 1, 0]; // 重置
      p0 = 0;
      p1 = 0;
      i = 0;
      drawArray(nums, i, p0, p1);
      setTimeout(animateSort, 800);
    }

    // 绑定按钮
    document.getElementById('restart').addEventListener('click', startAnimation);

    // 初始绘制
    drawArray(nums, i, p0, p1);
  </script>
</body>

</html>